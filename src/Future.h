//  (C) Copyright 2008-10 Anthony Williams
//  (C) Copyright 2011-2015 Vicente J. Botet Escriba
//
//  Distributed under the Boost Software License, Version 1.0.
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef BOOST_THREAD_FUTURE_HPP
#define BOOST_THREAD_FUTURE_HPP

#include <vector>
#include <utility>
#include <functional>
#include <type_traits>
#include <memory>
#include <nrf52840.h>

/// API required:
///  already_done_future(uint8_t | bool)
///     -> make_ready_future
///  dma_future, which takes a callback to check the done status and allows setting the value
///     -> future(), then set_done_callback (must allocate state_)
///  wrapped_future, which always leaves done true, but does reinterpret the value
///     -> f.then(||(*fut) { return make_ready_future<bool>(fut->get() == 0); })
///  chained_read_future, which takes a callback to return another future to wait on
///     -> f.then(||(*fut) { return do_next_read(); })

namespace future {
  class unique_irqlock {
    public:
      unique_irqlock() : m_needs_enable(irqs_enabled()) {
        __disable_irq();
      }
      ~unique_irqlock() { if (m_needs_enable) { __enable_irq(); } }
      unique_irqlock(const unique_irqlock& rhs) = delete;
      unique_irqlock& operator=(const unique_irqlock& rhs) = delete;

    private:
      bool irqs_enabled() {
        return (__get_PRIMASK() & 1) == 1;
      }
      bool m_needs_enable;
  };
  template<typename T>
  constexpr inline T volatile_load(const T* target) {
    static_assert(std::is_trivially_copyable<T>::value,
        "Volatile load can only be used with trivially copyable types");
    return *static_cast<const volatile T*>(target);
  }
  template<typename T>
  inline void volatile_store(T* target, T value) {
    static_assert(std::is_trivially_copyable<T>::value,
        "Volatile store can only be used with trivially copyable types");
    *static_cast<volatile T*>(target) = value;
  }
  template <typename T> class future;

  namespace detail {
    // A note on the structure here...
    //
    // Sadly we require a split-out shared_state so that continuations work;
    // without the split-out class, the value_type of the future returned by the
    // continuation callback would have to be the same as the current future's
    // value_type.  That is, it would not be possible to use .then() to convert
    // from one value_type to another.
    //
    // We require holding the done bit and the return value in the shared state
    // (and not in the future itself) because putting it into the future means
    // it's not possible for the continuation to hoist the return value from the
    // future that the callback returns, into the future that it's operating on
    // -- because the continuation shared state can't refer to the future that
    // owns it, because the future gets moved around on the stack.
    //
    // We require a non-templated shared_state_base so that continuations can
    // simply be a vector of pointers to something; it's not possible to have
    // different template args on the pointer types in the vector, so we need a
    // template-free type.  Fortunately the continuation handling does not need
    // to mess with the return value or done bit directly.
    //
    // But the is_done() handling needs to be split between the future and the
    // shared_state<R>, because the done_callback_ needs to take a pointer to
    // the future that it refers to (so that the user can set the return value
    // when the operation is done), and the shared_state<R> doesn't have any
    // way to get at the future<R>.
    //
    // So the structure is:
    //   shared_state_base            <- handles continuatons
    //   shared_state<R>              <- stores return value and done bit
    //   continuation_shared_state<R> <- stores preconditions
    //   future<R>   <- handles done_callback_, delegates to a shared_state<R>*
    //
    // That shared_state<R>* (actually a unique_ptr) might contain either a
    // vanilla shared_state<R>, or a continuation_shared_state<R> that handles
    // invoking continuations.

    struct shared_state_base {
      std::vector<shared_state_base*> continuations_;  // owned by their parent futures

      shared_state_base()
        : continuations_() {}
      shared_state_base(shared_state_base const&) = delete;
      shared_state_base& operator=(shared_state_base const&) = delete;

      virtual ~shared_state_base() {}
      virtual bool prereqs_done() { return true; }

      virtual void launch_continuation() {}

      void do_continuation() {
        if (!continuations_.empty()) {
          std::vector<shared_state_base*> the_continuations(std::move(continuations_));
          continuations_.clear();
          for (auto* cont : the_continuations) {
            cont->launch_continuation();
          }
        }
      }

      void set_continuation_ptr(shared_state_base* continuation) {
        unique_irqlock lock();
        continuations_.push_back(continuation);
      }
    };

    template <typename R>
    struct shared_state : public shared_state_base {
      bool done_;
      R result_;

      shared_state()
        : shared_state_base(),
          done_(false),
          result_() {}
      shared_state(shared_state const&) = delete;
      shared_state& operator=(shared_state const&) = delete;

      ~shared_state() override {}

      void set_done() {
        volatile_store(&done_, true);
      }

      bool is_done() {
        // Ruleset:
        //  If we've been given a callback, use and latch it; higher futures don't get a callback
        //  If we have prereqs (in the state), make sure all of them are done first.
        //  If during that process our alt_callback gets inited, make sure it's done.
        //  If all of them are done, wait for our own flag to be set.
        //
        // We've handled the callback in future::is_done, so only handle the
        // rest of the options here.
        if (!prereqs_done()) { return false; }
        return volatile_load(&done_);
      }
      void mark_finished_with_result(R&& result) {
        result_ = std::move(result);
        set_done();
        do_continuation();
      }

      R get() {
        return std::move(result_);
      }

      void set_continuation_ptr(shared_state_base* continuation) {
        shared_state_base::set_continuation_ptr(continuation);
        if (is_done()) {
          do_continuation();
        }
      }
    };
  }

  namespace detail {
    template<typename Return, typename PreconditionFuture, typename ContinuationF>
    future<Return>
    make_continuation_future(PreconditionFuture&& f, ContinuationF&& c);

    template<typename Return, typename PreconditionFuture, typename ContinuationF>
    struct continuation_shared_state;
  } // detail

  template <typename R>
  class future {
    private:
      typedef std::unique_ptr<detail::shared_state<R>> state_ptr;

      template<typename Return, typename PreconditionFuture, typename ContinuationF>
      friend future<Return>
      detail::make_continuation_future(PreconditionFuture&& f, ContinuationF&& c);
      template<typename Return, typename PreconditionFuture, typename ContinuationF>
      friend struct detail::continuation_shared_state;

      explicit future(state_ptr&& state)
        : state_(std::move(state)),
          done_callback_() {}

      state_ptr state_;
      std::function<bool(future<R>*)> done_callback_;

    public:
      future(future const&) = delete;
      future& operator=(future const&) = delete;
      typedef R value_type;

      constexpr future()
        : state_(std::make_unique<detail::shared_state<R>>()),
          done_callback_() {}

      ~future() {}

      future(future&& other)
        : state_(std::move(other.state_)),
          done_callback_(std::move(other.done_callback_)) {}

      future& operator=(future&& other) {
        state_ = std::move(other.state_);
        done_callback_ = std::move(other.done_callback_);
        return *this;
      }

      bool is_done() {
        // Ruleset:
        //  If we've been given a callback, use and latch it; higher futures don't get a callback
        //  If we have prereqs (in the state), make sure all of them are done first.
        //  If during that process our alt_callback gets inited, make sure it's done.
        //  If all of them are done, wait for our own flag to be set.
        //
        // Handle the callback here since it takes a pointer to the future;
        // handle the rest of the options in the shared_state::is_done.
        if (done_callback_) {
          if (!done_callback_(this)) {
            return false;
          }
          state_->set_done();
          done_callback_ = std::function<bool(future*)>();
          return true;
        }
        return state_->is_done();
      }
      template<typename F>
      void set_done_callback(F&& f) {
        done_callback_ = std::move(f);
      }
      void wait() {
        // TODO: should we wfi here?  will that break particle deviceos?
        while (!is_done()) {}
      }

      void mark_finished_with_result(R&& result) {
        state_->mark_finished_with_result(std::forward<R>(result));
        done_callback_ = std::function<bool(future*)>();
      }

      R get() { wait(); return state_->get(); }

      void set_continuation_ptr(detail::shared_state_base* continuation) {
        state_->set_continuation_ptr(continuation);
      }

      template<typename Func>
      inline future<typename std::result_of<Func(future)>::type::value_type>
      then(Func&& func) {
        typedef typename std::result_of<Func(future)>::type::value_type then_future_ret;

        return detail::make_continuation_future<then_future_ret>(
          std::move(*this), std::forward<Func>(func)
        );
      }
  };

  ////////////////////////////////
  // make_ready_future
  ////////////////////////////////
  template <class T>
  future<T> make_ready_future(typename std::remove_reference<T>::type & x) {
    future<T> f;
    f.mark_finished_with_result(x);
    return f;
  }

  template <class T>
  future<T> make_ready_future(typename std::remove_reference<T>::type&& x) {
    future<T> f;
    f.mark_finished_with_result(std::forward<typename std::remove_reference<T>::type>(x));
    return f;
  }

  namespace detail {
    //////////////////////
    template<typename Return, typename PreconditionFuture, typename ContinuationF>
    struct continuation_shared_state : public shared_state<Return> {
      PreconditionFuture precondition_;
      ContinuationF continuation_;
      future<Return> alt_precondition_;

      // NB: Because precondition is a reference, not just a rust style move,
      // changing it down in launch_continuation overwrites the state_ on the
      // original future.  Handle this in future::set_continuation_ptr.
      continuation_shared_state(PreconditionFuture&& precondition, ContinuationF&& c)
      : precondition_(std::move(precondition)),
        continuation_(std::move(c)),
        alt_precondition_(std::unique_ptr<shared_state<Return>>(nullptr)) {}

      void init() {
        precondition_.set_continuation_ptr(this);
      }

      ~continuation_shared_state() override {}

      // NB: There's no need for synchronization between launch and prereqs_done,
      // because the latter always happens in non-interrupt code (we never set
      // the result from the DMA IRQ, always from an is_done invoked callback),
      // and the former is always called when polling as well.
      bool prereqs_done() override {
        if (precondition_.state_) {
          return precondition_.is_done();
        }
        if (alt_precondition_.state_) {
          if (!alt_precondition_.is_done()) {
            return false;
          }
          shared_state<Return>::mark_finished_with_result(alt_precondition_.get());
        }
        return true;
      }
      void launch_continuation() override {
        //typename PreconditionFuture::value_type res = precondition_.result_;
        alt_precondition_ = continuation_(std::move(precondition_));
        precondition_ = PreconditionFuture(std::unique_ptr<shared_state<typename PreconditionFuture::value_type>>(nullptr)); // be sure to clear it
        //precondition_.result_ = res;
        //precondition_.set_done();
      }
    };

    ////////////////////////////////
    // make_continuation_future
    ////////////////////////////////
    template<typename Return, typename PreconditionFuture, typename ContinuationF>
    future<Return>
    make_continuation_future(PreconditionFuture&& f, ContinuationF&& c) {
      auto h = std::make_unique<continuation_shared_state<Return, PreconditionFuture, ContinuationF> >(std::forward<PreconditionFuture>(f), std::forward<ContinuationF>(c));
      h->init();

      return future<Return>(std::move(h));
    }
  }
}

#endif // header
